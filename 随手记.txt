URL示例：localhost:8080/Test/01
localhost	:表示本地，可换成127.0.0.1
8080	:表示端口号
/Test	:表示Servlet整个工程的发布名
/01	:表示下小的，具体的Servlet的名字，注解写法为@WebServlet("/01")

/01起名字有三种：同时匹配时，优先级由1-3，
1：精准匹配，例如/01，可同时精准匹配多个，写法为{"/01","/02","/03"}
2:/com/* ,*号匹配所有
3：*.do ,*号匹配所有，特别注意，/01.do会匹配到第一个

Servlet采用的是单例模式，为了线程安全，不要在Servlet中定义成员变量，如果定义了，方法中一定不要对其修改值。

请求对象常用方法：
获取请求行及各种路径：					实例结果
String 		getMethod()	获得请求方式(常用)		POST
String		getContextPath()	获取虚拟目录名称(常用)	/day36
String		getServletPath()	获取Servlet映射路径		/demo2
String		getRemoteAddr()	获取访问者ip地址		/0:0:0:0:0:0:0:1
String		getRequestURI()	获取统一资源标识符		/day36/demo2
StringBuffer	getRequestURL()	获取统一资源定位符		http://localhost:8080/day36/demo2
String		getProtocol()	获取协议及版本		HTTP/1.1
获取请求头信息：
String			getHeader(String name)	根据请求头名称获取一个值(常用)
Enumeration<String>	getHeaderNames()		获取所有请求头名称(基本不用)
获取请求参数信息：
String			getParameter(String name)		根据名称获取数据(常用)
String[]			getParameterValues(String name)	根据名称获取所有数据
Enumeration<String>	getParameterNames()		获取所有名称
Map<String,String[]>	getParameterMap()			获取所有参数的键值对(常用)
转发请求：
void	getRequestDispatcher(String name).forward(ServletRequest req,ServletResponse resp)	先获取请求调度对象，然后实现转发
转发情况下的共享数据：在一次请求的范围内实现资源共享，这个范围叫做request域
void	setAttribute(String name,Object obj)	存储数据，增加键值对
Object	getAttitude(String name)		获取数据，通过键，获取值
void	removeAttribute(String name)		删除数据，通过键，删除键值对

修复请求乱码：前端至后端时：
request.setCharacterEncoding("utf-8");	//只有POST方式有，GET方式乱码在Tomcat8.5版本后已解决
修复响应乱码：后端至前端时：
response.setContentType("text/html;charset=UTF-8");

重定向：
//1.设置状态码
response.setStatus(302);
//2。设置响应头
response.setHeader("location","http://www.baidu.com");

简化版：
response.sendRedirect("location","http://www.baidu.com");

字节输出流：
ServletOutputStream outputStream =  response.getOutputStream();
String s = "Hello World";
byte[] bytes = s.getBytes();
outputStream.write(bytes);

字符输出流：	//更常用，可以直接输出字符串
PrintWriter res = response.getWriter();
String s = "Hello World";
res.write(s);

响应乱码：后端至前端时：
response.setContentType("text/html;charset=UTF-8");

ServletContext:应用上下文对象，每个应用只有一个ServletContext对象
1.作为域对象，共享数据
2.获取MIME类型
3. 获取文件的真实(服务器)路径
有两种获取方式：
request.getServletContext();
this.getServletContext();
1.
这是Servlet中最大的一个域对象，包含整个应用，因此也叫Application域。所有的域对象有统一的API:
void	setAttribute(String name,Object obj)	存储数据，增加键值对
Object	getAttitude(String name)		获取数据，通过键，获取值
void	removeAttribute(String name)		删除数据，通过键，删除键值对
2.
MIME类型:在互联网通信过程中定义的一种文件数据类型,格式为"大类型/小类型",如同image/jpeg
String	getMimeType(String filename)	根据文件名获取该文件对应的MIME类型  //getMimeType("1.txt")
3.
获取文件真实路径：
String	getRealPath(String path)	获取文件的真实路径
web目录下资源访问
           String b = context.getRealPath("/b.txt")
WEB-INF目录下的资源访问
           String c = context.getRealPath("/WEB-INF/c.txt");
src目录下的资源访问
           String a = context.getRealPath("/WEB-INF/classes/a.txt");


文件下载思路四步：再加考虑中文乱码问题
1. 获取文件名称
2. 使用字节输入流加载文件进内存
3. 指定response的响应头： content-disposition:attachment;filename=xxx
4. 将数据写出到response输出流


Cookie:
//服务器想浏览器发送Cookie
        //1.创建cookie,绑定数据key:value
        Cookie cookie = new Cookie("KK","ZXCS");
        //2.通过响应将将cookie保存到浏览器
        response.addCookie(cookie);
//获取Cookie
        //1.通过request接受所有cookie
        Cookie[] arr = request.getCookies();
        //2.遍历数组，拿出每一个cookie
        if(arr != null && arr.length != 0){
            for (Cookie cookie : arr) {
                //2.1获取cookie名字
                String name = cookie.getName();
                //2.2获取cookie值
                String value = cookie.getValue();
                System.out.println(name+" : "+value);
            }

EL表达式：只能从域对象开始找，要request对象，则${pageContext.request.xxx}
字母则加空格
${key}			输出request域中key对应的value值,key不需要加“”
${1+2}			输出结果
${1 div 2} 除		输出结果
${1 mod 2}区域		输出结果
${1！=2}			输出true或者false
${empty msg}		输出true或者false,判断对象域key对应的值是否为null或长度为0
${1>2 ? "错":"对"}		三元表达式，True输出前者


/	div	除	
% 	mod	取余	
== 	eq	等于	(equal)
!= 	ne	不等于	
< 	lt	小于	(less than)
> 	gt	大于	(great than)
<= 	le	小于等于	
>= 	ge	大于等于	
&& 	and	并且
|| 	or	或者
! 	not	取反

四大域对象：
pageScope	->pageContext		范围太小，用的少，但可以用它得到request对象
requestScope	->request			
sessionScope	->session
applicationScope	->application(ServletContext)	范围太大，用的少

session是基于cookie的，每次请求会将session的唯一标识带过去从而找到session，遍历输出cookie可以看到，session的范围是一次请求的多次会话，
但持续30分钟无请求会自动销毁
获取session对象：HttpSession session1 = request.getSession();
获取session的唯一标识id: String id1 = session1.getId();
销毁session:session1.invalidate();//销毁后重新使用时会自动再次创建，获取Id就会发现创建了一个新的

${pageContext.key}用这种方式获得对象时，如果不加前面的域，则由小到大依次找
这里面得到的对象和Java里面没区别，后面可以.各种属性值，最后是打印最终对象的.toString()方法
集合可以如Pathon一样a[]来得到值

${pageContext.request.contextPath} 获得项目的虚拟路径，极常用，必须记住

























